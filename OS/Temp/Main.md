# 1. 커널
 운영체제는 하드웨어의 하드웨어 자원을 운영 관리하고 프로그램을 실행 할수 있는 환경을 제공하는 소프트웨어이다.  
 메모리에 상주하는 운영체제의 핵심부분을 커널이라고하며, 하드웨어를 운영관리하여 프로세스, 파일, 메모리, 통신 , 주변장치 등을 관리하는 서비스를 제공한다.  
 
   
### 1.1 커널이 제공하는 서비스  
* 프로세스 관리  
    여러 개의 프로그램이 실행될 수 있도록 프로세스들을 CPU 스케줄링 하여 마치 동시에 여러 프로세스들이 수행되는 것처럼 해준다.  

* 파일 관리  
    디스크와 같은 저장장치 상에 파일 시스템을 구성하고 파일을 유지 관리한다.  

* 메모리 관리  
    메인 메모리가 효율적으로 사용될 수 있도록 관리한다.  

* 통신관리  
    네트워크를 통해 정보를 효과적으로 주고받을 수 있도록 관리한다.

* 주변장치 관리  
    모니터, 키보드, 마우스와 같은 장치를 쉽고 편리하게 사용할 수 있도록 관리한다.

### 1.2 리눅스와 윈도우의 구조 
<img src="https://github.com/ryunian/Study/blob/master/image/kernel_Linux.png?raw=true" weight="500px" height="400px">
<img src="https://github.com/ryunian/Study/blob/master/image/kernel_Win.png?raw=true" weight="500px" height="400px">

쉘(shell)  
   > 사용자와 운영체제 사이의 인터페이스를 제공하는 특수 소프트웨어로, 사용자로부터 명령어를 입력받아 그 명령어를 해석하여 수행해주는 명령어 해석기이다.
        
### 1.3 커널모드와 사용자 모드
* 커널모드  
    > 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드로서,  
     이 모드에서는 모든 종류의 명령을 다 실행할 수 있다.
   
* 사용자모드  
    > 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.  
    하드웨어 접근 등 보안이 필요한 명령을 수행해야 할 경우 시스템 콜(System call)을 통해 운영체제가 대신해줄 것을 요청한다.
    
### 1.4 운영체제는 왜 두가지 모드를 지원하는가?
   * 하드웨어적인 보안을 유지하기 위함이다.  
   * 시스템에 중요한 영향을 미치는 연산은 커널모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지하는 것이다.  
   * 사용자 프로그램이 CPU를 가지고 있는 동안 자신의 코드를 실행시키지 못하게 하는 방법(하드웨어적)으로 CPU 내부에 모드비트(mode bit)를 두어
        사용자 프로그램을 감시하게 된다.     
        
        
        모드비트 0 : 커널모드로서 모든 명령을 수행할 수 있다. (인터럽트 발생 시, 모드비트는 항상 0임)  
        모드비트 1 : 사용자모드로서 제한된 명령만을 수행할 수 있다.

<br><br><br><br>

### 2. 인터럽트
   * 주변장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트라는 메커니즘을 통해 관리가 이루어진다.   
    주변장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하는데 이때 발생시키는 신호를 인터럽트라고 한다.
    
    
   * 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉘며,   
    하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅하며   
    소프트웨어 인터럽트는 소프트웨어가 그 일을 수행한다  (인터럽트라고 하면 보통 하드웨어 인터럽트를 의미한다)
    
<br><br>
    
### 2.1 소프트웨어 인터럽트
   트랩(trap)이라는 용어로 주로 불리며, 소프트웨어 인터럽트의 예로는 예외상황(exception)과 시스템콜(System call) 이 있다.

* 예외상황 : 사용자 프로그램이 0으로 나누는 연산 등 비정상적인 작업을 시도하거나,  
   자신의 메모리 영역 바깥에 접근하려는 시도 등 권한이 없는 작업을 시도할 떄 이에 대한 처리를 위해 발생시키는 인터럽트 이다.
        
* 시스템 콜(System call)
    일반적인 프로그램은 사용자 모드에서 실행되므로 커널 모드에 재한 직접적인 접근이 불가능하기 때문에   
    커널에 요청하여 커널모드에서 처리하고 그 결과를 사용자모드의 프로그램에 전달하는 것
    
    
    시스템콜의 과정
        1. 사용자 프로그램이 CPU에서 명령을 수행하던 중 디스크의 파일을 읽어야할 경우 발생
        2. 시스템 콜로 커널의 함수를 호출한다.
        3. 입출력 함수의 호출이 자신의 주소 공간에서 이루어질수 없기 때문에 사용자 프로그램을 잠시 멈춘 후 CPU의 제어권을 운영체제로 이양
        4. 설정된 인터럽트 라인에 의해 이번에 발생한 인터럽트가 입출력임을 인지한다.
        5. 서비스 루틴으로 이동해 입출력 작업을 수행 (컨트롤러, 여기선 디스크 컨트롤러)
        6. 사용자 프로그램은 봉쇄상태가 된다 (봉쇄상태가 된 사용자 프로그램은 중기스케줄러에 의해 스왑아웃 된다 (스왑아웃 0순위))
        7. CPU의 제어권은 다른 프로세스에게 이양된다 (효율적인 자원 활용을 위해)
        8. 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트(하드웨어 인터럽트)를 발생시켜 입출력 작업이 완료되었음을 알린다.
        9. CPU는 사용자 프로세스의 수행을 잠시 멈추고 인터럽트 처리루틴으로 그 제어권을 넘긴다. 
        10. 디스크로부터 로컬버퍼로 읽어온 내용을 메모리에 복사한뒤, 이전에 멈췄던 프로세스에게 제어권을 넘겨준다.
        11. 입출력된 프로세스는 레디 큐에 삽입된다.

   자바에서 시스템콜 하는 방법 

<br><br><br><br>

### 3. Context Switching
   * 문맥교환이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다.
    
   * 프로세스가 CPU의 할당을 받고 실행되던 중 타이머 인터럽트가 발생하면 CPU의 제어권은 운영체제에게 넘어가게 된다.
    그러면 운영체제는 타이머 인터럽트 처리 루틴으로 가서 직전까지 수행 중이던 프로세스의 문맥을 저장(문맥교환)하고 새롭게 실행시킬 프로세스에게 CPU를 이양한다.
    이 과정에서 원래 수행 중이던 프로세스는 준비 상태로 바뀌고 새롭게 CPU를 할당받은 프로세스는 실행 상태가 된다.
    
   * 문맥교환이 일어나면 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터값 등 프로세스의 문맥을 자신의 PCB에 저장하고, 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던
    자신의 문맥을 PCB로 부터 실제 하드웨어로 복원시키는 과정을 거친다. 
    
   * 문맥교환은 커널-사용자 모드 변경에 비해 훨씬 많은 오버헤드가 뒤따르게 되므로 주의 해야한다.

    
   * page 122사진추가예정
    
   스레드에서의 문맥교환
    
<br><br><br><br>

# 4. 동기화
### 4.1 Race Condition
   두 개 이상의 concurrent 한 스레드들이 공유된 자원에 접근하려고 할때 , 동기화된 메커니즘없이 접근하려고 하는 상황
<br><br>
    
###4.2 임계영역
   동일한 자원을 동시에 접근하는 작업을 실행하는 코드영역을 임계영역 (critical section) 이라고 한다.  
   이러한 영역에 동기화 매커니즘을 사용하지 않고 접근할 시 (Race Condition), 나타나는 문제를 임계영역문제라고 한다. 
    
   * 문재 해결을 위한 기본 조건 : 상호배제, 진행, 한정된 대기
        1. 상호배제 (Mutual Exclusion)
            어떤 프로세스가 임계영역을 실행하고 있을 때, 다른 프로세스는 임계영역을 실행할 수 없다.
            즉, 어떤 프로세스가 임계 영역을 실행할 떄, 다른 프로세스는 코드 실행을 못하게 처리해줘야 한다.
        
        2. 진행 (Progress)
            임계 영역에 실행되고 있는 프로세스가 없을 경우, 임계 영역을 실행하고자 기다리는 프로세스는 임계영역을 실행할수 있어야한다.
            즉, 기다리고 있는 프로세스들에 대한 처리를 해줘야한다.
        3. 한정 대기 (Bounded Waiting)
            임계 영역을 실행하고자 하는 프로세스가 무한정으로 대기하면 안된다.
            즉, 제한된 대기시간을 가져야 한다.
    
<br><br>
    
### 4.3 Busy Waiting
* 바쁜 대기란, A와 B라는 두개의 쓰레드가 공유 자원을 사용하려고 할때 쓰레드 A가 공유 자원을 먼저 사용하게 되면 쓰레드 B는 쓰레드 A가 사용을 마칠때 까지 기다려야 한다.  
이때 쓰레드 B는 쓰레드 A가 공유 자원 사용을 끝냈는지 계속 무한 루프를 돌면서 확인하게 되는데 이것을 Busy Waiting 이라고 한다.
* 지속적으로 확인하는 Busy Waiting이 아닌 block 방법으로 문제를 해결할 수 있다. (단, Wait Queue에 넣는 자원 비용 + Context Switching 비용 의 오버헤드가 발생한다.)
* 스핀락(Spin-lock)과 이것을 동일하게 생각하지만, 엄밀히 말하자면 스핀락이 바쁜 대기 개념을 이용한 것이다.

#####언제 사용하는 가?  
   * 자원의 권한을 얻는데 많은 시간이 소요되지 않는 상황인 경우.
   * Context Switching 비용보다 성능적으로 더 우수한 상황인 경우.

##### 단점 
   * 권한 획득을 위해 많은 CPU를 낭비한다.
   
<br><br>
   
### 4.4 LOCK
* 하나의 스레드나 프로세스가 자원을 사용하고 있는 동안에는 잠궈서 접근을 못하게 하는 방식

* 동시에 공유 자원에 접근하는 것을 막기 위해 임계영역에 진입하는 프로세스나 스레드는 Lock을 흭득하고 임계영역을 빠져나올떄,  
    Lock 을 방출함으로써 동시에 접근이 되지 않도록 한다.
    
* 락은 크게 인터럽트 제어 방법(controlling interrupts)과 소프트웨어적 방법론으로만 제작하는 방법(software-only algorithm)과  
    하드웨어를 활용하여 제작하는 방법(Hardware atomic Instructions) 세 가지가 있습니다. 

<br><br>

##### 4.4.1 소프트웨어 알고리즘
   1. 피터슨 알고리즘
   2. 데커 알고리즘
   
<br><br>
   
##### 4.4.2 더 이상 쪼개지지 않는 하드웨어 명령어로 구현하는 방법
   1. Test-and-Set  
        > 원자성을 가진 하드웨어 명령어를 이용하여 락을 구현한다. 락 소유가 가능할 때까지 루프를 돌며 대기하기 때문에 스핀 락이라고 부른다
         
   2. Comapare-and-Swap  
        > 현재 쓰레드에 저장된 값과 메인 메모리에 저장된 값을 비교하여 일치하는 경우 새로운 값으로 교체하고 일치하지 않는다면 실패하고 재시도를 한다
        
   3. Load-Linked(LL) and Store-Conditional(SC)  
        > Load-Linked를 통해 현재 lock이 free인지 확인한다.(free가 아니라면 spin 한다.) 그리고 store-conditional 을 통해 lock 소유한다.   
        이때 핵심은 lock의 free 여부를 확인한 이후 lock을 소유하는 사이에 인터럽트가 발생하여 다른 스레드가 lock을 소유하는 경우가 발생한다는 점이다.
        그럼 다음 기회를 기다려야 한다.
   
   4. Fetch-and-Add  
        > 티켓 락이란 여러 스레드에 티켓을 주고, 락이 free 되었을 때, 차례와 티켓이 동일하면 락을 소유하는 방법이다.   
        가장 큰 차이점은 모든 스레드들이 순서대로 진행하게 된다는 점이다.
   
<br><br>
   
##### 4.4.3 인터럽트를 disable하고 enable하는 방법
   * 단일 프로세서 시스템의 경우엔 disabling interrupt로 상호배제 가능
   * 하지만 application 레벨에서 이를 악용하여 interrupt를 막아서 control을 독점할 수 있음
   * 멀티 프로세서에서는 동작하지 않음

<br><br>

### 4.5 뮤텍스

<br><br>

### 4.6 세마포
   * 세마포어는 Signaling 메커니즘이라는 점에서 뮤텍스와 다르다.   
   세마포어는 락을 걸지 않은 쓰레드도 Signal을 보내 락을 해제할 수 있다는 점에서, wait 함수를 호출한 쓰레드만이 signal 함수를 호출할 수 있는 뮤텍스와 다르다.

   * 세마포어는 동기화를 위해 wait와 signal이라는 2개의 atomic operations를 사용한다.

   * wait를 호출하면 세마포어의 카운트를 1줄이고, 세마포어의 카운트가 0보다 작거나 같아질 경우에 락이 실행된다. 

   * Semaphore의 cnt 값은 지정한 만큼 한 공유 자원에 대해 여러 스레드가 돌게 할 수도 있다.
   
   * 초기에는 busy wating을 이용하는 방법이였지만, 단점을 보안하여 sleep queue를 활용하여 프로세스를 재우는 방식을 사용한다.
   
##### 4.6.1 종류
   * 카운팅 세마포
           세마포어의 카운트가 양의 정수값을 가지며, 설정한 값만큼 쓰레드를 허용하고,
           그 이상의 쓰레드가 자원에 접근하면 락이 실행된다.
           
   * 이진 세마포
           이진 세마포어는 세마포어의 카운트가 1이며 Mutext'처럼' 사용될 수 있다.

##### 4.6.2 단점
   * wait함수(P), signal함수(V)는 서로 독립적이기 떄문에 잘못 사용하는 경우 문제가 발생한다.
   * 고급 언어에서 동기화를 제공해야 한다.
   
##### 4.6.3 소스

<br><br><br>

### 4.7 모니터

<br><br><br><br>

# 5. 데드락
img - 식사하는 철학자들
img - 




<br><br><br><br><br><br>


Q. 운영체제를 메모리에 상주하지 않고 왜 커널만 따로 메모리에 상주시키는가?  
    - 메모리가 부족해지기 때문
    
Q. 프로세스가 실행 상태일때 시스템콜이나 인터럽트가 발생하여 CPU의 제어권이 운영체제로 넘어와 실행중이던 프로세스가 멈추고 운영체제의 커널코드가 실행된다. 
    이떄, 문맥교환이 일어나는가? (단, I/O요청같이 봉쇄상태로 바뀌는 요청이 아니다.)
    - 프로세스의 문맥 중 일부를 PCB에 저장하지만 이러한 과정을 문맥교환이라고 하지않는다.
    - 프로세스의 실행모드만 사용자모드에서 커널모드로 바뀌는 것일뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 떄문이다.
    
    

출처    
-

-Busy Waiting-
https://simsimjae.tistory.com/289
https://nesoy.github.io/articles/2019-06/OS-Busy-Waiting

-lock-
https://blackinkgj.github.io/Locks/
https://jaegoon.netlify.app/posts/OS/lock?no-cache=1
https://yunmorning.tistory.com/50
https://blackinkgj.github.io/Locks/
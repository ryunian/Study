# 1. 커널
 운영체제는 하드웨어의 하드웨어 자원을 운영 관리하고 프로그램을 실행 할수 있는 환경을 제공하는 소프트웨어이다.  
 메모리에 상주하는 운영체제의 핵심부분을 커널이라고하며, 하드웨어를 운영관리하여 프로세스, 파일, 메모리, 통신 , 주변장치 등을 관리하는 서비스를 제공한다.  
 
   
### 1.1 커널이 제공하는 서비스  
* 프로세스 관리  
    여러 개의 프로그램이 실행될 수 있도록 프로세스들을 CPU 스케줄링 하여 마치 동시에 여러 프로세스들이 수행되는 것처럼 해준다.  

* 파일 관리  
    디스크와 같은 저장장치 상에 파일 시스템을 구성하고 파일을 유지 관리한다.  

* 메모리 관리  
    메인 메모리가 효율적으로 사용될 수 있도록 관리한다.  

* 통신관리  
    네트워크를 통해 정보를 효과적으로 주고받을 수 있도록 관리한다.

* 주변장치 관리  
    모니터, 키보드, 마우스와 같은 장치를 쉽고 편리하게 사용할 수 있도록 관리한다.

<br><br>

### 1.2 리눅스와 윈도우의 구조 
<img src="https://github.com/ryunian/Study/blob/master/image/kernel_Linux.png?raw=true" width="500px" height="400px">
<img src="https://github.com/ryunian/Study/blob/master/image/kernel_Win.png?raw=true" width="500px" height="400px">

쉘(shell)  
   > 사용자와 운영체제 사이의 인터페이스를 제공하는 특수 소프트웨어로, 사용자로부터 명령어를 입력받아 그 명령어를 해석하여 수행해주는 명령어 해석기이다.
    
<br><br>
        
### 1.3 커널모드와 사용자 모드
* 커널모드  
    > 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드로서,  
     이 모드에서는 모든 종류의 명령을 다 실행할 수 있다.
   
* 사용자모드  
    > 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.  
    하드웨어 접근 등 보안이 필요한 명령을 수행해야 할 경우 시스템 콜(System call)을 통해 운영체제가 대신해줄 것을 요청한다.
    
<br><br>
    
### 1.4 운영체제는 왜 두가지 모드를 지원하는가?
   * 하드웨어적인 보안을 유지하기 위함이다.  
   * 시스템에 중요한 영향을 미치는 연산은 커널모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지하는 것이다.  
   * 사용자 프로그램이 CPU를 가지고 있는 동안 자신의 코드를 실행시키지 못하게 하는 방법(하드웨어적)으로 CPU 내부에 모드비트(mode bit)를 두어
        사용자 프로그램을 감시하게 된다.     
        
        
        모드비트 0 : 커널모드로서 모든 명령을 수행할 수 있다. (인터럽트 발생 시, 모드비트는 항상 0임)  
        모드비트 1 : 사용자모드로서 제한된 명령만을 수행할 수 있다.

<br><br><br><br>

### 2. 인터럽트
   * 주변장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트라는 메커니즘을 통해 관리가 이루어진다.   
    주변장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하는데 이때 발생시키는 신호를 인터럽트라고 한다.
    
    
   * 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉘며,   
    하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅하며   
    소프트웨어 인터럽트는 소프트웨어가 그 일을 수행한다  (인터럽트라고 하면 보통 하드웨어 인터럽트를 의미한다)
    
<br><br>
    
### 2.1 소프트웨어 인터럽트
   트랩(trap)이라는 용어로 주로 불리며, 소프트웨어 인터럽트의 예로는 예외상황(exception)과 시스템콜(System call) 이 있다.

* 예외상황 : 사용자 프로그램이 0으로 나누는 연산 등 비정상적인 작업을 시도, Page Fault가 발생하거나
   자신의 메모리 영역 바깥에 접근하려는 시도 등 권한이 없는 작업을 시도할 떄 이에 대한 처리를 위해 발생시키는 인터럽트 이다.
        
* 시스템 콜(System call)
    일반적인 프로그램은 사용자 모드에서 실행되므로 커널 모드에 재한 직접적인 접근이 불가능하기 때문에   
    커널에 요청하여 커널모드에서 처리하고 그 결과를 사용자모드의 프로그램에 전달하는 것
    
    
    시스템콜의 과정
        1. 사용자 프로그램이 CPU에서 명령을 수행하던 중 디스크의 파일을 읽어야할 경우 발생
        2. 시스템 콜로 커널의 함수를 호출한다.
        3. 입출력 함수의 호출이 자신의 주소 공간에서 이루어질수 없기 때문에 사용자 프로그램을 잠시 멈춘 후 CPU의 제어권을 운영체제로 이양
        4. 설정된 인터럽트 라인에 의해 이번에 발생한 인터럽트가 입출력임을 인지한다.
        5. 서비스 루틴으로 이동해 입출력 작업을 수행 (컨트롤러, 여기선 디스크 컨트롤러)
        6. 사용자 프로그램은 봉쇄상태가 된다 (봉쇄상태가 된 사용자 프로그램은 중기스케줄러에 의해 스왑아웃 된다 (스왑아웃 0순위))
        7. CPU의 제어권은 다른 프로세스에게 이양된다 (효율적인 자원 활용을 위해)
        8. 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트(하드웨어 인터럽트)를 발생시켜 입출력 작업이 완료되었음을 알린다.
        9. CPU는 사용자 프로세스의 수행을 잠시 멈추고 인터럽트 처리루틴으로 그 제어권을 넘긴다. 
        10. 디스크로부터 로컬버퍼로 읽어온 내용을 메모리에 복사한뒤, 이전에 멈췄던 프로세스에게 제어권을 넘겨준다.
        11. 입출력된 프로세스는 레디 큐에 삽입된다.

<br><br><br><br>

### 3. Context Switching
   * 문맥교환이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다.
    
   * 프로세스가 CPU의 할당을 받고 실행되던 중 타이머 인터럽트가 발생하면 CPU의 제어권은 운영체제에게 넘어가게 된다.
    그러면 운영체제는 타이머 인터럽트 처리 루틴으로 가서 직전까지 수행 중이던 프로세스의 문맥을 저장(문맥교환)하고 새롭게 실행시킬 프로세스에게 CPU를 이양한다.
    이 과정에서 원래 수행 중이던 프로세스는 준비 상태로 바뀌고 새롭게 CPU를 할당받은 프로세스는 실행 상태가 된다.
    
   * 문맥교환이 일어나면 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터값 등 프로세스의 문맥을 자신의 PCB에 저장하고, 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던
    자신의 문맥을 PCB로 부터 실제 하드웨어로 복원시키는 과정을 거친다. 
    
   * 문맥교환은 커널-사용자 모드 변경에 비해 훨씬 많은 오버헤드가 뒤따르게 되므로 주의 해야한다.

<br><br><br><br>

# 4. 동기화
### 4.1 Race Condition
   두 개 이상의 concurrent 한 스레드들이 공유된 자원에 접근하려고 할때 , 동기화된 메커니즘없이 접근하려고 하는 상황
   
<br><br>
    
###4.2 임계영역
   동일한 자원을 동시에 접근하는 작업을 실행하는 코드영역을 임계영역 (critical section) 이라고 한다.  
   이러한 영역에 동기화 매커니즘을 사용하지 않고 접근할 시 (Race Condition), 나타나는 문제를 임계영역문제라고 한다. 
    
   * 문재 해결을 위한 기본 조건 : 상호배제, 진행, 한정된 대기
        1. 상호배제 (Mutual Exclusion)
            어떤 프로세스가 임계영역을 실행하고 있을 때, 다른 프로세스는 임계영역을 실행할 수 없다.
            즉, 어떤 프로세스가 임계 영역을 실행할 떄, 다른 프로세스는 코드 실행을 못하게 처리해줘야 한다.
        
        2. 진행 (Progress)
            임계 영역에 실행되고 있는 프로세스가 없을 경우, 임계 영역을 실행하고자 기다리는 프로세스는 임계영역을 실행할수 있어야한다.
            즉, 기다리고 있는 프로세스들에 대한 처리를 해줘야한다.
        3. 한정 대기 (Bounded Waiting)
            임계 영역을 실행하고자 하는 프로세스가 무한정으로 대기하면 안된다.
            즉, 제한된 대기시간을 가져야 한다.
    
<br><br>
    
### 4.3 Busy Waiting
* 바쁜 대기란, A와 B라는 두개의 쓰레드가 공유 자원을 사용하려고 할때 쓰레드 A가 공유 자원을 먼저 사용하게 되면 쓰레드 B는 쓰레드 A가 사용을 마칠때 까지 기다려야 한다.  
이때 쓰레드 B는 쓰레드 A가 공유 자원 사용을 끝냈는지 계속 무한 루프를 돌면서 확인하게 되는데 이것을 Busy Waiting 이라고 한다.
* 지속적으로 확인하는 Busy Waiting이 아닌 block 방법으로 문제를 해결할 수 있다. (단, Wait Queue에 넣는 자원 비용 + Context Switching 비용 의 오버헤드가 발생한다.)
* 스핀락(Spin-lock)과 이것을 동일하게 생각하지만, 엄밀히 말하자면 스핀락이 바쁜 대기 개념을 이용한 것이다.

#####언제 사용하는 가?  
   * 자원의 권한을 얻는데 많은 시간이 소요되지 않는 상황인 경우.
   * Context Switching 비용보다 성능적으로 더 우수한 상황인 경우.

##### 단점 
   * 권한 획득을 위해 많은 CPU를 낭비한다.
   
<br><br>
   
### 4.4 LOCK
* 하나의 스레드나 프로세스가 자원을 사용하고 있는 동안에는 잠궈서 접근을 못하게 하는 방식

* 동시에 공유 자원에 접근하는 것을 막기 위해 임계영역에 진입하는 프로세스나 스레드는 Lock을 흭득하고 임계영역을 빠져나올떄,  
    Lock 을 방출함으로써 동시에 접근이 되지 않도록 한다.
    
* 락은 크게 인터럽트 제어 방법(controlling interrupts)과 소프트웨어적 방법론으로만 제작하는 방법(software-only algorithm)과  
    하드웨어를 활용하여 제작하는 방법(Hardware atomic Instructions) 세 가지가 있습니다. 

<br><br>

##### 4.4.1 소프트웨어 알고리즘
   1. 데커 알고리즘  
        상호배제를 하는 최초의 알고리즘으로 turn과 flag 두 가지를 사용하여 구현한 것이다.  
        먼저 깃발을 들고 확인한 다음 turn을 확인하는 방법이다. turn을 확인하고 자신의 차례가 아니면 깃발을 내리고 자신의 차례면 기다린다.  
        자기 차례가 오면 깃발을 들고 임계영역에 진입하고, 끝나면 깃발내리고 차례를 넘겨준다.
   
   2. 다익스트라 알고리즘  
        프로세스 n개의 상호배제 문제를 해결한 최초의 알고리즘이다.  
        CS에 진입하기 위해 단계를 2단계로 나누어 단계마다 진입할 수 있는 프로세스를 걸러내어   
        최종적으로 하나의 프로세스만 CS에 접근할 수 있게 구현되었습니다.  
   
   3. 램퍼드의 베이커리 알고리즘
        프로세스 n개의 상호 배제 문제를 해결한 알고리즘이다.  
        bakery 알고리즘은 프로세스에게 고유한 번호를 부여하고,  
        번호를 기준으로 우선순위를 정하여 우선순위가 높은 프로세스가 먼저 임계 구역에 진입하도록 구현되었다.
   
   3. 피터슨 알고리즘  
        flag와 turn이라는 변수로 임계영역에 들어갈 프로세스(혹은 스레드)를 결정하는 방식이다.  
    	데커 알고리즘과 상당히 유사하지만 상대방(다른 프로세스 혹은 스레드)에게 진입기회를 양보한다는 차이가 있다.   
    	flag값은 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수이고,   
    	turn 변수는 누가 임계영역에 들어갈 차례인지 나타내는 변수이다.  
    	 
     
   
<br><br>
   
##### 4.4.2 더 이상 쪼개지지 않는 하드웨어 명령어로 구현하는 방법
   1. Test-and-Set  
        > 원자성을 가진 하드웨어 명령어를 이용하여 락을 구현한다. 락 소유가 가능할 때까지 루프를 돌며 대기하기 때문에 스핀 락이라고 부른다
         
   2. Compare-and-Swap  
        > 현재 쓰레드에 저장된 값과 메인 메모리에 저장된 값을 비교하여 일치하는 경우 새로운 값으로 교체하고 일치하지 않는다면 실패하고 재시도를 한다
        
   3. Load-Linked(LL) and Store-Conditional(SC)  
        > Load-Linked를 통해 현재 lock이 free인지 확인한다.(free가 아니라면 spin 한다.) 그리고 store-conditional 을 통해 lock 소유한다.   
        이때 핵심은 lock의 free 여부를 확인한 이후 lock을 소유하는 사이에 인터럽트가 발생하여 다른 스레드가 lock을 소유하는 경우가 발생한다는 점이다.
        그럼 다음 기회를 기다려야 한다.
   
   4. Fetch-and-Add  
        > 티켓 락이란 여러 스레드에 티켓을 주고, 락이 free 되었을 때, 차례와 티켓이 동일하면 락을 소유하는 방법이다.   
        가장 큰 차이점은 모든 스레드들이 순서대로 진행하게 된다는 점이다.
   
<br><br>
   
##### 4.4.3 인터럽트를 disable하고 enable하는 방법
   * 단일 프로세서 시스템의 경우엔 disabling interrupt로 상호배제 가능
   * 하지만 application 레벨에서 이를 악용하여 interrupt를 막아서 control을 독점할 수 있음
   * 멀티 프로세서에서는 동작하지 않음

<br><br>

### 4.5 뮤텍스 (Mutex)
   * Locking 메커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계영역에 들어올수있으며,
    이 쓰레드만이 임계영역에서 나갈 때 뮤텍스를 해제할 수 있다.
    
   * 동작
    공유자원 X에 대해서 쓰레드A 와 쓰레드B 에 접근하여 각각 수정,조회하는 작업을 한다면, 이 경우 두 쓰레드간 동기화가 되어야 Thread-Safe 하다.  
    그래서 쓰레드 A가 수정하는 경우는 다른 스레드가 그 값을 수정/조회하지 못하도록 막아놓고(LOCK: mutex를 set한다)
    그 작업이 끝나면 잠금을 풀어주어(Unlock: mutex를 clear한다) 쓰레드B가 공유자원 X에 대해서 조회되는 로직을 처리한다.
    
    
    ※ Thread-safe
        멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다  
        하나의 함수가 한 스레드로부터 호출되어 실행 중일 때,   
        다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것으로 정의한다.
 

<br><br>

### 4.6 세마포 (세마포어 , Semaphore)
   * 세마포는 Signaling 메커니즘이라는 점에서 뮤텍스와 다르다.   
   세마포는 락을 걸지 않은 쓰레드도 Signal을 보내 락을 해제할 수 있다는 점에서, wait 함수를 호출한 쓰레드만이 signal 함수를 호출할 수 있는 뮤텍스와 다르다.

   * 세마포는 동기화를 위해 wait(P)와 signal(V)이라는 2개의 atomic operations를 사용한다.

   * wait를 호출하면 세마포어의 카운트를 1줄이고, 세마포어의 카운트가 0보다 작거나 같아질 경우에 락이 실행된다. 

   * 세마포의 cnt 값은 지정한 만큼 한 공유 자원에 대해 여러 스레드가 돌게 할 수도 있다.
   
   * 초기에는 busy wating을 이용하는 방법이였지만, 단점을 보안하여 block 과 wakeup 방식으로 sleep lock을 구현한다.
   
<br>
   
##### 4.6.1 종류
   * 카운팅 세마포
           세마포어의 카운트가 양의 정수값을 가지며, 설정한 값만큼 쓰레드를 허용하고,
           그 이상의 쓰레드가 자원에 접근하면 락이 실행된다.
           
   * 이진 세마포
           이진 세마포어는 세마포어의 카운트가 1이며 Mutex '처럼' 사용될 수 있다.

<br>

##### 4.6.2 단점
   * wait함수(P), signal함수(V)는 서로 독립적이기 떄문에 잘못 사용하는 경우 문제가 발생한다.
   * 고급 언어에서 동기화를 제공해야 한다.
    
<br>
    
##### 4.6.3 세마포를 활용한 java 소스
```java
import java.util.concurrent.Semaphore;

public class SemaphoreTest {
    public static void main(String[] args) {
        final Reseouce resource = new Reseouce(3);
        for (int i = 1; i <= 10; i++) {
            Thread t = new Thread(() -> resource.use());
            t.start();
        }
    }

    static class Reseouce {
        private final Semaphore semaphore;
        private final int maxThread;

        public Reseouce(int maxThread) {
            this.semaphore = new Semaphore(maxThread);
            this.maxThread = maxThread;
        }

        public void use() {
            try {
                // Thread 가 세마포에게 시작을 알림
                semaphore.acquire();

                System.out.printf("[%s] %d개의 쓰레드가 점유중\n"
                        , Thread.currentThread().getName()
                        , (maxThread - semaphore.availablePermits()));
                // semaphore.availablePermits() 사용가능한 Thread의 숫자

                Thread.sleep((long) (Math.random() * 10000));

                semaphore.release(); // Thread 가 세마포에게 종료를 알림
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

<br><br><br>

### 4.7 모니터
   > 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태이다.    
   > 공유자원에 접근하기 위한 키 흭득과 자원 사용 후 해제를 모두 처리한다.  
   > 베타동기, 조건동기라는 두개의 queue를 활용하여 임계영역 접근 문제를 해결한다.
   > 세마포어에 비해서 모니터 쪽이 공유자원에 접근할 수 있는 키의 획득과 해제를 모두 처리해서 간단하다.
 
   * 베타동기 : 하나의 스레드만 공유자원에 접근하게 해준다. 공유자원을 사용하는 스레드가 존재하면, 베타동기에서 대기한다. (synchronized)  
   * 조긴동기 : 공유자원을 사용하는 스레드가 Block을 당하면서, 새로운 스레드가 진입하게 해준다. (notify, notifyAll, wait)
	
	Ex)
	    Synchronized가 메소드에 선언되어있고, 
	    쓰레드A가 이미 Lock을 획득해서 Critical Section(메소드)을 수행중이라고 가정하자. 
	    쓰레드B가 동일한 메소드를 수행하기 위해 해당 Object의Lock을 획득해야 할 것이다. 
	    이 Lock이 반환될 때까지 대기를 해야하는데 그 때 사용되는게 바로 Monitor다. 
	    쓰레드A가 Lock을 반환하면 쓰레드B는 기다렸다가 Lock을 획득하게 된다. 
	    그리고 Critical Section인 메소드를 수행할 수 있게 된다. 
	    물론 Synchronized 키워드를 사용했을 때 자동적으로 수행되는 내부 동작이고, 별도로 명시적인 Monitor를 구현할 수도 있다.
	    Monitor는 이렇게 Mutex(Lock)과 Condition Variables을 이용해서 Mutual Exclustion을 해결하고 있다.
	    그 외 Monitor의 다른 정의로는 공유자원에 안전하게 접근하기 위해 Mutual Exclusion가 랩핑된 Thread-Safe한 클래스, 객체, 모듈들을 의미하기도 한다.

<br><br><br><br>

# 5. 데드락
<img src="https://github.com/ryunian/Study/blob/master/image/deadLock1.png?raw=true" width="500px" height="400px">
<img src="https://github.com/ryunian/Study/blob/master/image/deadLock2.png?raw=true" width="500px" height="400px">

### 5.1 식사하는 철학자 문제
   > 1. 일정 시간 생각을 한다.  
   > 2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.  
   > 3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.  
   > 4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.  
   > 5. 오른쪽 포크를 내려놓는다.  
   > 6. 왼쪽 포크를 내려놓는다.  
   > 7. 다시 1번으로 돌아간다.  

<br><br>

### 5.2 정의
두 개 이상의 프로세스가 각자 먼저 확보한 자원을 가진 채 상대방의 자원을 필요로 할 경우, 외부로부터의 조치가 없는 한 이들은 아무 일도 못하고 계속 기다리는 현상  
데드락은 아무리 좋은 동기화 프로세스를 사용해도 발생하며, 특정 코딩 규칙을 사용하는 등을 이용하여 교착상태가 일으킬 가능성을 줄여야 한다.  

발생 조건 : 상호배제, 점유대기, 비선점, 순환대기 중 전부를 만족할 시 발생한다.

    * 상호 배제 (Mutual exclusion)
        자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다
        
    * 점유 대기 (Hold and wait)
        최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
    
    * 비선점 (No preemption)
        다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.      
    
    * 순환 대기 (Circular wait)
        프로세스의 집합 {P0 ~ Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 
        P2 ~ Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.

<br><br>

### 5.3 예방 (Prevention)
> 교착 상태 발생 조건 중 하나를 제거하면서 해결한다. (자원 낭비가 심하다)

    1) 상호 배제 (Mutual exclusion) 부정
         여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.

    2) 점유 대기 (Hold and wait) 부정
         프로세스가 실행되기 전 필요한 모든 자원을 할당한다.

    3) 비선점 (No preemption) 부정
         자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.

    4) 순환 대기 (Circular wait) 부정
         자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.

### 5.4 회피 (Avoidance)
> 교착 상태 발생 시 피해나가는 방법 (은행원 알고리즘)

   - 은행원 알고리즘 :
        프로세스가 자원을 요구할 떄, 시스템은 자원을 할당한 후에도 안정 상태로 남아 있게 되는지 사전에 검사하여 교착 상태 회피
				
		단점  
		    최대 자원 요구량을 미리 알아야하며, 쉽게 구현이 가능하지만, 추가비용이 크다.
			프로세스는 유한한 시간에 자원을 반납해야 한다.

<br><br>

### 5.5 교착 상태 탐지 및 회복
> 교착 상태가 되도록 허용한 다음에 회복시키는 방법  
대부분의 시스템은 교착 상태가 잘 발생하지 않으며, 교착 상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다.

<br><br>

##### 5.5.1 탐지 (Detection)

> 자원 할당 그래프를 통해 교착 상태를 탐지, 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드가 발생

<br><br>

##### 5.5.2 회복 (Recovery)
> 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법  

1. 프로세스를 종료하는 방법  
    * 교착 상태의 프로세스를 모두 중지  
    * 교착 상태가 제거될 떄까지 한 프로세스씩 중지

2. 자원을 선점하는 방법
    * 교착 상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며, 해당 프로세스를 일시 정지 시키는 방법  
    * 우선 순위가 낮은 프로세스, 수행된 횟수가 적은 프로세스 등을 위주로 프로세스의 자원을 선점한다.  

<br><br><br><br><br>
<hr><hr><hr><hr><hr>
<br><br><br><br><br>


Q. 운영체제를 메모리에 상주하지 않고 왜 커널만 따로 메모리에 상주시키는가?  
    - 메모리가 부족해지기 때문
    
Q. 프로세스가 실행 상태일때 시스템콜이나 인터럽트가 발생하여 CPU의 제어권이 운영체제로 넘어와 실행중이던 프로세스가 멈추고 운영체제의 커널코드가 실행된다. 
    이떄, 문맥교환이 일어나는가? (단, I/O요청같이 봉쇄상태로 바뀌는 요청이 아니다.)
    - 프로세스의 문맥 중 일부를 PCB에 저장하지만 이러한 과정을 문맥교환이라고 하지않는다.
    - 프로세스의 실행모드만 사용자모드에서 커널모드로 바뀌는 것일뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 떄문이다.

Q. Java에서 시스템콜을 직접 하는 방법은?
- 없다. 단, 직접할수는 없지만 미리 정의된 API를 통해 간접적(JVM을 통해서)으로 가능하다. 
    
Q. 뮤텍스와 세마포는 자신만 해제가 가능하다 O, X
- X, 뮤텍스는 lock을 가진 스레드만 뮤텍스를 해제가 가능하지만, 세마포는 락을 걸지 않는 쓰레드도 Signal을 보내 락을 해제할수 있다.

Q. A와 B가 화장실을 갈라고한다. 그런데 화장실이 하나뿐이고 카운터에서 열쇠를 받아 가야한다.
    이떄, 뮤텍스와 세마포 중 어떤것을 적용해야 할까?
- 뮤텍스, 이진세마포 또한 안된다. 세마포는 lock(여기선 열쇠)를 가지지 않는 스레드가 해제가 가능하기 떄문이다.


Q. 식사를 하는 철학자에 대한 해결법을 말해보시오  
- n명이 앉을 수 있는 테이블에서 철학자를 n-1명만 앉힘  
- 한 철학자가 젓가락 두개를 모두 집을 수 있는 상황에서만 젓가락 집도록 허용  
- 누군가는 왼쪽 젓가락을 먼저 집지 않고 오른쪽 젓가락을 먼저 집도록 허용  

<br><br><br><br><br>
<hr><hr><hr><hr><hr>
<br><br><br><br><br>

출처
-Busy Waiting-
https://simsimjae.tistory.com/289
https://nesoy.github.io/articles/2019-06/OS-Busy-Waiting

-lock-
https://blackinkgj.github.io/Locks/
https://jaegoon.netlify.app/posts/OS/lock?no-cache=1
https://yunmorning.tistory.com/50
https://blackinkgj.github.io/Locks/

-상호배제-
https://yoongrammer.tistory.com/61#%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_(Dijkstra_algorithm)

-세마포-
https://parkcheolu.tistory.com/28
https://javaplant.tistory.com/30

-모니터-
https://about-myeong.tistory.com/34

-교착상태-
https://jwprogramming.tistory.com/m/12

-서적-
운영체제와 정보기술의 원리


 
# 1.0 커널
 운영체제는 하드웨어의 하드웨어 자원을 운영 관리하고 프로그램을 실행 할수 있는 환경을 제공하는 소프트웨어이다.  
 메모리에 상주하는 운영체제의 핵심부분을 커널이라고하며, 하드웨어를 운영관리하여 프로세스, 파일, 메모리, 통신 , 주변장치 등을 관리하는 서비스를 제공한다.  
 
### 1.1 커널이 제공하는 서비스  
* 프로세스 관리  
    여러 개의 프로그램이 실행될 수 있도록 프로세스들을 CPU 스케줄링 하여 마치 동시에 여러 프로세스들이 수행되는 것처럼 해준다.  

* 파일 관리  
    디스크와 같은 저장장치 상에 파일 시스템을 구성하고 파일을 유지 관리한다.  

* 메모리 관리  
    메인 메모리가 효율적으로 사용될 수 있도록 관리한다.  

* 통신관리  
    네트워크를 통해 정보를 효과적으로 주고받을 수 있도록 관리한다.

* 주변장치 관리
    모니터, 키보드, 마우스와 같은 장치를 쉽고 편리하게 사용할 수 있도록 관리한다.

### 1.2 리눅스와 윈도우의 구조 
- 사진첨부

쉘(shell) 
    사용자와 운영체제 사이의 인터페이스를 제공하는 특수 소프트웨어로, 사용자로부터 명령어를 입력받아 그 명령어를 해석하여 수행해주는 명령어 해석기이다.
        
### 1.3 커널모드와 사용자 모드
* 커널모드  
    > 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드로서,  
     이 모드에서는 모든 종류의 명령을 다 실행할 수 있다.
   
* 사용자모드  
    > 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.  
    하드웨어 접근 등 보안이 필요한 명령을 수행해야 할 경우 시스템 콜(System call)을 통해 운영체제가 대신해줄 것을 요청한다.
    
### 1.4 운영체제는 왜 두가지 모드를 지원하는가?
   * 하드웨어적인 보안을 유지하기 위함이다.  
   * 시스템에 중요한 영향을 미치는 연산은 커널모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지하는 것이다.  
   * 사용자 프로그램이 CPU를 가지고 있는 동안 자신의 코드를 실행시키지 못하게 하는 방법(하드웨어적)으로 CPU 내부에 모드비트(mode bit)를 두어
        사용자 프로그램을 감시하게 된다.     
        
        
        모드비트 0 : 커널모드로서 모든 명령을 수행할 수 있다. (인터럽트 발생 시, 모드비트는 항상 0임)  
        모드비트 1 : 사용자모드로서 제한된 명령만을 수행할 수 있다.


### 2.0 인터럽트
   * 주변장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트라는 메커니즘을 통해 관리가 이루어진다. 주변장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜
    서비스를 요청하는데 이때 발생시키는 신호를 인터럽트라고 한다.
    
    
   * 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉘며,   
    하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅하며   
    소프트웨어 인터럽트는 소프트웨어가 그 일을 수행한다  (인터럽트라고 하면 보통 하드웨어 인터럽트를 의미한다)
    
### 2.1 소프트웨어 인터럽트
   트랩(trap)이라는 용어로 주로 불리며, 소프트웨어 인터럽트의 예로는 예외상황(exception)과 시스템콜(System call) 이 있다.

* 예외상황 : 사용자 프로그램이 0으로 나누는 연산 등 비정상적인 작업을 시도하거나, 
   자신의 메모리 영역 바깥에 접근하려는 시도 등 권한이 없는 작업을 시도할 떄 이에 대한 처리를 위해 발생시키는 인터럽트 이다.
        
* 시스템 콜(System call)
    일반적인 프로그램은 사용자 모드에서 실행되므로 커널 모드에 재한 직접적인 접근이 불가능하기 때문에 커널에 요청하여 커널모드에서 처리하고 그 결과를 사용자모드의 프로그램에 전달하는 것
    
    
    시스템콜의 과정
    1. 사용자 프로그램이 CPU에서 명령을 수행하던 중 디스크의 파일을 읽어야할 경우 발생
    2. 시스템 콜로 커널의 함수를 호출한다.
    3. 입출력 함수의 호출이 자신의 주소 공간에서 이루어질수 없기 때문에 사용자 프로그램을 잠시 멈춘 후 CPU의 제어권을 운영체제로 이양
    4. 설정된 인터럽트 라인에 의해 이번에 발생한 인터럽트가 입출력임을 인지한다.
    5. 서비스 루틴으로 이동해 입출력 작업을 수행 (컨트롤러, 여기선 디스크 컨트롤러)
    6. 사용자 프로그램은 봉쇄상태가 된다 (봉쇄상태가 된 사용자 프로그램은 중기스케줄러에 의해 스왑아웃 된다 (스왑아웃 0순위))
    7. CPU의 제어권은 다른 프로세스에게 이양된다 (효율적인 자원 활용을 위해)
    8. 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트(하드웨어 인터럽트)를 발생시켜 입출력 작업이 완료되었음을 알린다.
    9. CPU는 사용자 프로세스의 수행을 잠시 멈추고 인터럽트 처리루틴으로 그 제어권을 넘긴다. 
    10. 디스크로부터 로컬버퍼로 읽어온 내용을 메모리에 복사한뒤, 이전에 멈췄던 프로세스에게 제어권을 넘겨준다.
    11. 입출력된 프로세스는 레디 큐에 삽입된다.


### 3.0 Context Switching
   * 문맥교환이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다.
    
   * 프로세스가 CPU의 할당을 받고 실행되던 중 타이머 인터럽트가 발생하면 CPU의 제어권은 운영체제에게 넘어가게 된다.
    그러면 운영체제는 타이머 인터럽트 처리 루틴으로 가서 직전까지 수행 중이던 프로세스의 문맥을 저장(문맥교환)하고 새롭게 실행시킬 프로세스에게 CPU를 이양한다.
    이 과정에서 원래 수행 중이던 프로세스는 준비 상태로 바뀌고 새롭게 CPU를 할당받은 프로세스는 실행 상태가 된다.
    
   * 문맥교환이 일어나면 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터값 등 프로세스의 문맥을 자신의 PCB에 저장하고, 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던
    자신의 문맥을 PCB로 부터 실제 하드웨어로 복원시키는 과정을 거친다. 
    
   * 문맥교환은 커널-사용자 모드 변경에 비해 훨씬 많은 오버헤드가 뒤따르게 되므로 주의 해야한다.

    * page 122사진추가예정
    
    
    
    
Q. 운영체제를 메모리에 상주하지 않고 왜 커널만 따로 메모리에 상주시키는가?
- 메모리가 부족해지기 때문

Q. 프로세스가 실행 상태일때 시스템콜이나 인터럽트가 발생하여 CPU의 제어권이 운영체제로 넘어와 실행중이던 프로세스가 멈추고 운영체제의 커널코드가 실행된다. 
이떄, 문맥교환이 일어나는가? (단, I/O요청같이 봉쇄상태로 바뀌는 요청이 아니다.)
- 프로세스의 문맥 중 일부를 PCB에 저장하지만 이러한 과정을 문맥교환이라고 하지않는다.
- 프로세스의 실행모드만 사용자모드에서 커널모드로 바뀌는 것일뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 떄문이다.
- 


임계영역
Race Condition
Lock
busy-waits
Sleeping
피터슨 알고리즘

세마포
뮤텍스
모니터
데드락
# 1. 메모리 관리
<img src="https://github.com/ryunian/Study/blob/master/image/MemoryAllocation.png?raw=true" width="500" height="300"/>

* 논리적주소 (logical address)  
    프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간생기며 이를 논리적 주소 또는 가상 주소(virtual address) 라고 부른다.  
    논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지 부터 시작된다.

* 물리적주소 (physical address)  
    낮은 주소영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

* 주소바인딩 (address binding)  
    프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소바인딩이라고 한다.

<br><br>

### 1.1 주소바인딩의 방법
* 컴파일 타임 바인딩 (compile time binding)  
	물리적 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식  
	물리적 메모리의 위치를 변경하고 싶다면 컴파일을 다시 해야한다.  
	그러므로 현대의 시분할 컴퓨팅 환경에서는 잘 사용하지 않는다.  

* 로드 타임 바인딩 (load time binding)  
	프로그램의 실행이 시작될 떄에 물리적 메모리 주소가 결졍되는 방식  
	바인딩 방식에서는 로더(loader)의 책임하에 물리적 메모리 주소가 부여되며 프로그램이 종료될떄 까지 물리적 메모리상의 위치가 고정된다.  
	
	- 로더 : 사용자 프로그램을 메모리에 적재시키는 프로그램
	
* 실행시간 바인딩 (execution time binding,  run time binding)  
	프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 방식  
	CPU가 주소를 참조할 떄마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블을 이용해 바인딩을 점검한다.  
	실행시간 바인딩 방식이 가능하기 위해, 기준 레지스터(base register)와 한계 레지스터(limit register)를 포함해 MMU라는 하드웨어적인 지원이 있어야한다.  

<br><br>

### 1.2 MMU (Memory Management Unit)
> 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치
>	
> CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 떄 MMU 기법은 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다.
>	
> MMU 기법에서는 프로그램의 주소공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다.
>	
> MMU 기법에서는 문맥교환으로 CPU에서 수행 중인 프로세스가 바뀔때마다 재배치 레지스터의 값을 그 프로세스에 해당되는 값으로 재설정한다.
>
> 논리적 주소값과 재배치 레지스터 안에 있는 값을 더한 결과가 해당 프로세스의 주소 공간을 벗어나는 경우가 발생할수 있다, 이를 방지하기 위해 한계 레지스터(limit register)라는 또 하나의 레지스터를 사용한다.
	
   * 기준 레지스터
		재배치 레지스터라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.
	
   * 한계레지스터 
		프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용된다.
	
<br><br>

### 1.3 동적 적재 (dynamic loading)
> 프로세스가 시작될 떄 그 프로세스의 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라 메모리를 좀더 효율적으로 사용하기 위해 해당 부분이 호출될 때 그부분만을 메모리에 적재하는 방식을 사용한다.  
>
> 즉, 프로세스 내에서 실행에 필요한 부분이 실제로 불릴 떄마다 메모리에 적재한다.
	
※ 위에서 알아본 기법들은 프로세스의 주소공간 전체가 메모리에 적재된다.

<br><br>

### 1.4 동적연결 (dynamic linking)  
> 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법이다.  
> 실행파일에 라이브러리 코드가 포함되지 않으며, 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어진다.  
> 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하므로 메모리 사용의 효율성을 높힐수 있다.
	
	
   * 연결 (linking)
		소스코드를 컴파일 하여 생성된 목적파일과 라이브러리 파일들을 묶어 하나의 실행파일을 생성하는 과정
	
   * 스텁 (stub)
		실행파일의 라이브러리 호출 부분에 해당 라이브러리의 위치를 찾기 위한 작은 코드

<br><br>

### 1.5 중첩 (overlays)
> 프로세스의 주소 공간을 분할해 실제 필요한 부분을 메모리에 적재하는 기법
> 	
> 동적로딩과 개념적으로 비슷하나, 중첩은 메모리의 크기 제약으로 인해 필요한 일부분을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후에 나머지 부분을 올려 실행하는 기법이다
> 	
> 동적로딩은 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도이고
> 중첩은 단일 프로세스만을 메모리에 올려놓는 환경에서 용량보다 큰 프로세스를 실행하기 위한 선택이다.
 
<br><br>
 
### 1.6 스와핑 (swapping)
> 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려놓는 것을 말한다. 
	
* 스왑영역 :디스크 내의 파일 시스템과는 별도로 존재하는 일정 영역
* 스왑인 : 프로세스의 주소공간을 메모리 <- 디스크로 올리는 작업
* 스왑인 : 프로세스의 주소공간을 메모리 -> 디스크로 내리는 작업

<br><br>

### 1.7 외부 단편화 (external fragmentation)
프로그램의 크기보다 분할의 크기가 작은 경우,  
해당 분할이 비어있는데도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간  

즉, 어떠한 프로그램에게도 배정되지 않는 빈 공간임에도 현재 상태에서 사용될수 없는 작은 분할

<br><br>

### 1.8 내부 단편화 (internal fragmentation)
프로그램의 크기보다 분할의 크기가 큰 경우,  
해당 분할에 프로그램을 적재하고 남는 메모리 공간

즉, 하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각


<br><br><br><br>

# 2. 메모리 연속할당 (contiguous allocation)
### 2.1 고정분할
물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행시킬수 있게 한다.  
분할의 크기는 모두 동일하게 할수도 있고 다르게 할수 있지만, 하나의 분할에는 하나의 프로그램만을 적재할수 있다.
	
   * 동시에 메모리에 올릴수 있는 프로그램의 수가 고정되어 있다.
   * 수행 가능함 프로그램의 최대 크기가 고정 되어 있다.
   * 외부단편화 및 내부단편화가 발생할 수 있다.

<br><br>

### 2.2 가변분할
> 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식이다.  
> 프로그램의 크기를 고려해서 메모리를 할당하고 이를 기술적으로 관리할 수 있는 기법이 필요하다.
	
내부단편화는 발생하지 않지만, 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며,  
이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 외부 단편화가 발생한다.
	
물리적 메모리 내 가용 공간 중 어떤 위치에 올릴 것인지 결정하는 동적 메모리 할당 문제가 있다.
	
* 가용공간 : 사용되지 않은 메모리 공간 (메모리 내의 여러 곳에 존재할수 있다.)

### 2.2.1 동적 메모리 할당 문제
최초적합 (first-fit)

	- 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당하는 방법
	
	장점)
		시간적인 측면에서 효율적이다.

최적적합 (best-fit)

	- 크기가 n 이상인 가장 작은 가용 공간을 찾아 그곳에 프로세스를 할당하는 방법
	
	장점)
		공간적인 측면에서 효율적이다.
	
	단점)
		모든 가용공간 리스트를 탐색할수 있으므로 시간적 오버헤드가 발생
		다수의 작은 가용 공간들이 생성될 수 있다

최악적합 (worst-fit)

	- 가용 공간 중에서 가장 크기가 큰 곳에 프로세스를 할당 하는 방법
	
	단점)
		모든 가용공간 리스트를 탐색함으로 시간적 오버헤드가 발생
		큰 프로그램을 담을 수 있는 가용 공간이 빨리 소진된다.

<br><br>

### 2.2.2 컴팩션 (compaction)
> 가변분할 방식에서 발생하는 외부조각 문제를 해결하기 위한 방법  
>
> 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법
	
* 비용도 크고, 메모리 위치를 옮겨야 하므로 실행시간 바인딩 방식 환경에서만 가능하다.

<br><br><br><br>

# 3. 메모리 불연속 할당 (noncontiguous allocation)
### 3.1 페이징
> 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식
> 
> 각 프로세스의 주소 공간 전체를 물리적 메모리에 전부 올릴 필요가 없으며,  
> 일부는 스왑영역 (백킹스토어)에 일부는 물리적 메모리에 혼재 시키는 것이 가능하다.
> 	
> 물리적 메모리를 페이지와 동일한 크기의 프레임(frame) 으로 미리 나누어 둔다.  
> 메모리에 올리는 단위가 동일한 크기의 페이지 단위이므로, 메모리를 같은 크기로 미리 분할해두더라도 빈 프레임이 있으면 어떤 위치이든 사용될수 있다.
> 	
> 모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블(page table)을 가지며,  
> 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 된다.

<img src="https://github.com/ryunian/Study/blob/master/image/paging.png?raw=true" width="500" height="300"/>

<br><br>

장점)
1. 연속할당에서 발생했던 동적 메모리 할당 문제가 발생하지 않는다.
		
2. 프로세스의 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위로 나누어지기 떄문에,  
메모리상의 가용 공간의 크기가 작아서 빈 공간임에도 할용되지 못하는 [외부단편화] 문제가 발생하지 않는다.


단점)
1. 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에
    프로세스의 주소 공간 중 제일 마지막에 위치한 페이지에서는 [내부단편화]가 발생할 가능성이 있다.

<br><br>

#### 3.1.1 주소 변환기법
CPU가 사용하는 논리적 주소를 페이지번호(p)와 페이지 오프셋(d)으로 나누어 주소변환(address translation)에 사용한다.
페이지 번호는 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 인덱스로 사용되고
해당 인덱스의 항목(entry)에는 그 페이지의 물리적 메모리상의 기준 주소, 즉 시작 위치가 저장된다.
특정 프로세스의 p번쨰 페이지가 위치한 물리적 메모리의 시작 위치를 알고 싶다면 해당 프로세스의 페이지 테이블에서 p번쨰 항목을 찾아보면 된다.
페이지 오프셋은 하나의 페이지 내에서의 변위를 알려준다.
기준 주소값에 변위를 더함으로써 요청된 논리적 주소에 대응하는 물리적 주소를 얻을수 있다.

#### 3.1.2 페이지테이블의 구현
페이지 테이블은 페이징 기법에서 주소 변환을 하기 위한 자료구조로, 물리적 메모리에 위치하게된다.
프로세스의 페이지 테이블에 접근하기 위해 운영체제는 페이지 테이블 기준레지스터와 페이지 테이블 길이 레지스터를 사용한다.

페이지 테이블 기준 레지스터 : 메모리 내에서의 페이지 테이블의 시작위치를 가리킨다.  
페이지 테이블 길이 레지스터 : 페이지 테이블의 크기를 보관한다.

메모리 접근 연산은 주소변환을 위해 페이지 테이블에 접근하는 것과 변환된 주소에서 실제 데이터에 접근하는것, 이렇게 두번의 메모리 접근을 필요로 한다. 
즉 메모리에 한번 접근하기 위해서는 매번 메모리에 두번 접근해야 하는 오버헤드가 뒤따른다.
이를 해결하기 위해 TLB라고 불리는 고속의 주소 변환용 하드웨어 캐시가 사용되기도 한다.

TLB내에 주소 변환 정보가 존재한다면대응하는 물리적 메모리의 프레임 번호를 얻을 수 있지만, TLB에 존재하지 않는 경우에는 메인 메모리에 있는 페이지 테이블로부터 프레임 번호를 알아야한다.
TLB는 페이지 번호와 프레임 번호가 쌍으로 저장되어 있으며, TLB를 통한 주소 변환을 위해서는 해당 페이지에 대한 주소 변환 정보가 TLB에 있는지 확인하기 위해 TLB의 모든 항목을 다 찾아야 하는 오버헤드가 발생한다. 이를 줄이기 위해 TLB구현에는 일반적으로 병렬탐색(TLB내의 모든 항목을 동시에 탐색할 수 있는 기능) 이 가능한 연관 레지스터를 사용한다.

<br><br>

#### 3.1.3 계층적 페이징
주소 공간이 매우 큰 프로그램을 지원함으로써, 전체 메모리의 상당 부분이 주소 변환을 위한 페이지 테이블에 할애되어 실제로 사용 가능한 메모리 공간이 줄어들게된다. 대부분의 프로그램은 주소 공간 중 지극히 일부분만을 사용하므로 페이지 테이블을 위한 메모리 의 사용은 심각한 공간 낭비이다.
따라서 페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 2단계 페이징 기법을 사용한다.
논리적 주소 -> 외부페이지 테이블 -> 내부 페이지 테이블 -> 물리적 메모리

<br><br>

#### 3.1.4 역페이지 테이블
페이지 테이블로 인한 메모리 공간의 낭비가 심한 이유는 모든 프로세스의 모든 페이지에 대해 페이지 테이블 항목을 다 구성해야하기 때문이다. 이를 해결하기 위한 대안으로 역페이지 테이블 기법이 사용된다.
역페이지 테이블은 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩 항목을 두는 방식이다. 논리적 주소에 대해 페이지 테이블을 만드는 것이 아니라, 물리적 주소에 대해 페이지 테이블을 만드는 것이다.

<br><br>

#### 3.1.5 공유 페이지
공유코드는 재진입 가능코드 또는 순수 코드라고 불리며 읽기전용 특성을 가지고 있다. 공유 페이지란 공유 코드를 담고있는 페이지를 말한다.
공유페이지는 여러 프로세스에 의해 공유되는 페이지이므로 물리적 메모리에 하나만 적재되어 메모리를 좀 더 효율적으로 사용할 수 있게 한다.
공유 페이지는 그 페이지를 공유하는 모든 프로세스의 주소 공간에서 동일한 페이지 번호를 가져야한다.


<br><br>

### 3.2 세그먼테이션
> 페이징은 프로세스의 주소 공간을 동일한 크기 단위로 나누어 물리적 메모리에 올리지만,  
> 세그먼테이션은 프로세스의 주소 공간을 세그먼트(segment)로 나누어 물리적 메모리에 올리는 것을 말한다.   

<img src="https://github.com/ryunian/Study/blob/master/image/segmentation.jpg?raw=true" width="500" height="300"/>

#### 3.2.1 세그먼트  
> 주소공간을 기능 단위 또는 의미 단위로 나눈 것을 뜻한다.
>
> 프로세스의 주소 공간 전체를 크게는 하나의 세그먼트로 볼 수도 있으며,   
> 일반적으로는 코드,데이터 스택 등의 기능 단위로 세그먼트를 정의한다.
>  
> 세그먼트가 이와 같이 특정 크기 단위로 나눈 것이 아니라 의미를 가질 수 있는 논리적인 단위로 나눈 것이기 떄문에 크기가 균일하지 않다.  

<br>

    1. 세그먼테이션 기법에서는 논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘어 사용되며, 
       [세그먼트 번호] 는 해당 논리적 주소가 프로세스 주소 공간 내에서 얼마만큼 떨어져 있는지에 대한 정보를 나타낸다. 
       [오프셋] 은 세그먼트 내에서 얼마만큼 떨어져 있는지에 대한 정보를 나타낸다. 


    2. 세그먼테이션 기법에서는 주소 변환을 위해 세그먼트 테이블을 사용하며, 세그먼트 테이블은 기준점(base)과 한계점(limit)을 가지고 있다.
  
   
    3. [기준점 (base)] 은 물리적 메모리에서 세그먼트의 시작위치를 나타내며, 
       [한계점 (limit)] 은 세그먼트의 길이를 나타낸다. (세그먼트의 길이가 균일하지 않기 떄문)
  
  
    4. 세그먼테이션 기법에서는 세그먼트 테이블 기준 레지스터, 세그먼트 테이블 길이 레지스터를 사용한다.
    
        4.1 세그먼트 테이블 기준 레지스터 (Segment-Table Base Register : STBR)
            현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블이 메모리의 어느 위치에 있는지 그 시작주소를 담고 있다.
    
        
        4.2 세그먼트 테이블 길이 레지스터 (Segment-Table Length Register : STLR)   
        	프로세스의 주소 공간이 총 몇개의 세그먼트로 구성되는지, 즉 세그먼트의 개수를 나타낸다.           

<br>
* 과정)
    1. 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인지 체크한다.
    2. 작지 않을 경우, 예외상황을 발생시켜 메모리 접근을 봉쇄한다.
    3. 논리적 주소의 오프셋값이 세그먼트의 길이보다 작은 값인지 체크한다.
    4. 이를 위해 세그먼트 테이블의 한계점과, 요청된 논리적 주소의 오프셋값을 비교해 확인한다.
    5. 세그먼트 길이를 넘어서는 오프셋 위치에 접근시도일 경우, 예외상황을 발생시켜 메모리 접근을 봉쇄한다.
    6. 두 가지를 체크해서 정상일 경우, 메모리 접근요청으로 판단하여 주소 변환 작업이 이루어진다.    

* 장점)  
    세그먼트는 의미 단위로 나누어져 있기 때문에 공유와 보안의 측면에서 페이징 기법보다 좋다.

* 단점)  
    세그먼트의 길이가 균일하지 않기 떄문에 외부조각이 발생한다.  
    가변분할 방식에서의 나타나는 문제(동적 메모리 할당 문제)가 발생한다. (최초적합, 최적적합 방식이 있다.)


<br><br>

### 3.3 페이지드 세그먼테이션
> 페이징 기법과 세그먼테이션 기법의 장점만 취하는 주소 변환 기법으로,   
> 프로그램을 의미 단위의 세그먼트로 나눈다.   
> 단, 세그먼트가 임의의 길이를 가질 수 있는 것이 아니라 반드시 동일 한 크기 페이지 들의 집합으로 구성 되어있다.  
> 물리적 메모리에 적재하는 단위는 페이지 단위이다.  
>
    즉, 페이지드 세그먼테이션 기법에서는 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로  
    세그먼테이션 기법에서 발생하는 외부조각의 문제점을 해결하며,   
    
    동시에 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어 지도록 함으로써
    페이징 기법의 약점을 해소한다.

<br>

특징)
* 주소 변환을 위해 외부의 세그먼트테이블과 내부의 페이지 테이블을 사용한다.
* 하나의 세그먼트가 여러 개의 페이지로 구성되므로 각 세그먼트마다 페이지테이블을 가지며, 2단계 페이지 테이블과 유사한 구조이다.

<br><br>

##### <세그먼트 번호, 오프셋> 으로 구성된 논리적 주소를 물리적 주소로 변환하는 과정
1. 논리적 주소의 상위 비트인 세그먼트 번호를 통해 세그먼트 테이블의 해당 항목에 접근
2. 세그먼트 항목에는 세그먼트 길이와 그 세그먼트의 페이지 테이블 시작주소가 들어 있다.
3. 세그먼트 길이를 넘어서는 메모리 접근 시도인지 여부를 체크
4. 유효할 경우, 오프셋값을 다시 상위/하위비트로 나누어 상위 비트는 그 세그먼트 내에서의 페이지 번호로 사용
5. 하위비트는 페이지 내에서의 변위로 사용
6. 세그먼트 테이블의 항목을 통해 해당 세그먼트를 위한 페이지 테이블의 시작 위치를 얻었으므로, 
그 위치에서 페이지 번호만큼 떨어진 페이지 테이블 항목으로부터 물리적 메모리의 페이지 프레임 위치를 얻게된다.





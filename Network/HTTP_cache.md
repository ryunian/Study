# Web cache (Http cache)
> 사용자(client)가 웹 사이트(server)에 접속할 때, 정적 컨텐츠(이미지, JS, CSS 등)를 특정 위치(client, network 등)에 저장하여, 
> 웹 사이트 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라,   
> 특정 위치에서 불러옴으로써 사이트 응답시간을 줄이고, 서버 트래픽 감소 효과를 볼 수 있다.
> 
> 캐시는 크게, 사설(private) 혹은 공유(shared) 캐시 두 가지 부류로 분류될 수 있다.   
> **공유 캐시**는 한 명 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시를 말한다.   
> **사설 캐시**는 한 명의 사용자만 사용하는 캐시를 말한다.

장점)

- 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다.
- 한 기관에서 인터넷으로 접속하는 링크상의 웹 트래픽을 대폭으로 줄일 수 있다.

<br><br>

## 3.1 브라우저 캐시

- 브라우저 또는 HTTP요청을 하는 Client Application에 의해 내부 디스크에 캐쉬
- Cache된 Resource를 공유하지 않는 한 개인에 한정된 Cache
- 브라우저의 Back버튼 또는 이미 방문한 페이지를 재 방문하는 경우 극대화
- 요청이 네트워크를 통해 전송되지 않기 때문에 왕복 시간(RTT, Round Trip Time)이 발생하지 않는다.

<br><br>

## 3.2 프록시 서버

> 프록시서버는 원출처의 웹 서버를 대신하여 HTTP 요구를 충족시키는 네트워크 개체이다.

* 프록시서버는 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다.  
* 브라우저가 설정되면 객체에 대한 각각의 브라우저 요청은 웹 캐시에 가장 먼저 보내진다.


    프록시 서버를 통한 클라이언트의 객체 요청의 흐름
    1. 브라우저는 프록시 서버와 TCP 연결을 설정하고 
    프록시 서버에 있는 객체에 대한 HTTP 요청을 보낸다.

    2. 프록시 서버는 객체의 사본이 자기에게 저장되어 있는지 확인한다.

    3-1 저장되어 있을 시, 
        프록시 서버는 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.

    3-2 저장이 안되어 있을시, 
        프록시 서버는 원출처의 서버로 TCP 연결을 설정한다.
        프록시 서버는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보낸다.
        요청을 받은 후, 기점 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보낸다.

    4. 프록시 서버가 객체를 수신할 떄, 객체를 지역 저장장치에 복사하고 
        클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보낸다.

<br><br>

## 3.3 조건부 GET (conditional GET)

> HTTP는 모든 객체들이 최신의 것임을 확인하면서 캐싱하는 방식을 조건부 GET이라고 한다.
> 
> 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는것과 다를 경우에만 객체 본문을 보내달라고 하는 것이다.
>
> 조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더(검증 헤더) 를 추가함으로써 시작된다.  
> If-Modified-Since: Last-Modified 사용  
> If-None-Match: ETag 사용  
>
> 조건이 만족 시 200 OK  
> 조건이 만족하지 않으면 304 Not Modified

<br><br>

### If-Modified-Since (날짜 재검사)
> 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.

* 만약 문서가 주어진 날짜 이후에 변경되지 않았다면, 조건은(If-Modified-Since) 거짓이고
* 서버는 304 Not Modified 응답메세지를 클라이언트에게 보내준다. (Body는 보내지 않는다)
* 응답 헤더들을 포함하지만, 원래 돌려줘야 할 것에서 갱신이 필요한 것만을 보내준다. 
(보통 새 만료 날짜만 보내준다.)

<br>

* 단점)
    > 1초 단위의 날짜 기반 로직을 사용하기 떄문에, 아래와 같은 경우가 발생한다.

    1. 일정 시간 간격으로 다시 쓰여지지만, 같은 데이터를 포함한다. (내용변화가 없음)
    2. 어떤 문서들의 변경은 다시 읽어들이기엔 사소한 것 (철자나 주석)
    3. 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없다.
    4. 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는,변경일에 대한 1초의 정밀도는 충분하지 않을 수 있다.

<br><br>

### If-None-Match (엔티티 태그 재검사)
> ETag(Entity Tag) : 캐시용 데이터에 임의의 고유한 버전 이름을 달아두는 것  
> 데이터가 변경되면 Hash를 다시 생성한다. 

* 즉, 캐시된 태그가 서버에 있는 문서의 태그와 다를 떄만 요청을 처리한다.

<br><br><br><br>

## 3.4 캐시 제어 헤더

### 3.4.1 Cache-Control

> 캐시 제어

- max-age : 캐시 유효 시간, 초 단위
- no-cache : 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
- no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨
    - (메모리에서 사용하고 최대한 빨리 삭제)
- public : 응답이 public 캐시에 저장되어도 됨
- private : 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함 (default)
- s-maxage : 프록시 캐시에만 적용되는 max-age
- must-revalidate
    - 캐시 만료후 최초 조회시 원 서버에 검증해야 함
    - 원 서버 접근 실패시 반드시 오류가 발생해야함 (504 Gateway Timeout)
    - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
    - no-cache 임에도 원서버가 장애가 발생 시 프록시 캐시에서의 설정에 의해 프록시 캐시가 반응할수도 있기 때문에 사용한다.

### 3.4.2 Pragma

> 캐시제어 (하위 호환)

- no-cache
- HTTP 1.0 하위호환

### 3.4.3 Expires

> 캐시 유효 기간 (하위 호환)

- 캐시 만료일을 정확한 날짜로 지정
- 지금은 더 유연한 Cache-Control: max-age 권장 (함께 사용시 무시된다.)

<br><br>

## 3.5 전체 흐름

<img src="https://github.com/ryunian/Study/blob/master/image/Cache.png?raw=true" width="700px" height="500px">
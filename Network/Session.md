# 세션

> 일정 시간동안 같은 사용자(브라우저)로부터 들어오는일련의 요구를 하나의 상태로 보고,  
> 그 상태를 일정하게 유지시키는 기술이다.
> 
> 여기서 일정 시간은 방문자가 웹 브라우저를 통해  
> 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.

- 즉, **방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션**이라고 한다.


<br><br>


## 2.1 특징

- 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.

- 웹 서버의 저장되는 쿠키(=세션 쿠키)

- 브라우저를 닫거나, 서버에서 세션을 삭제했을때만 삭제가 되므로,쿠키보다 비교적 보안이 좋다.

- 저장 데이터에 제한이 없다.(서버 용량에 따라 다르다.)

- 각 클라이언트 고유 Session ID를 부여한다. 
    Session ID로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스 제공

<br><br>

## 2.2 흐름

1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)

2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여,클라이언트가 해당 session-id를 보냈는지 확인한다.

3. session-id가 존재하지 않는다면,서버는 session-id를 생성해 클라이언트에게 돌려준다.

4. 서버에서 클라이언트로 돌려준 session-id를 쿠키(JSESSIONID)를 사용해 서버에 저장한다.

5. 클라이언트는 재접속 시,이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달

<br><br>

## 2.3 분산 환경에서의 Session 관리

### 2.3.1 Sticky Session

> 고정된 세션 의미한다.  
> Load Balance가 기본적으로 라운드 로빈 방식으로 트래픽을 분산하며,  
> Sticky Session 의 핵심은 로드밸런스가 동일한 인스턴스로 사용자 요청을 일관되게 라우팅 하도록하느냐 이다.


즉, 특정 사용자가 접속을 시도했을 떄 처음 접속된 서버로 계속해서 접속되도록 트래픽을 처리하는 방식이다.
 

- 정합성 이슈에서 자유로워질 수 있다.
- 특정 서버에 트래픽이 집중될 위험이 있기 떄문에 하나의 서버에 트래픽이 집중되더라도 다른서버를 사용할 수가 없다.
- 또한, 하나의 서버에 장애가 발생한다면 해당 서버를 사용하는 사용자들은 세션정보를 잃게 되어 가용성이 떨어진다. (즉, failover가 안된다)

![Untitled](%E1%84%89%E1%85%A6%E1%84%89%E1%85%A7%E1%86%AB%2025b78b03a7494e97b95d61ccfd8fef0e/Untitled.png)

<br><br>

### 2.3.2 Session Clustering

> Session Clustering 은 정합성 이슈를 해결하면서 가용성과 트래픽 분산까지 확보 할 수 있는 세션관리 방식이다.
> 
- Clustering 이란 여러 대의 컴퓨터들이 하나의 시스템처럼 동작하도록 만드는 것이며,
- Session Clustering은 WAS가 2대 이상 설치 형태일 떄 동일한 세션으로 관리하는 것을 의미한다.
- 즉, 특정 WAS에 세션 객체가 생성되면 다른 WAS에 세션 객체가 복제된다.

단점)

1. 모든 서버가 동일한 세션 객체를 가져야하기 때문에 많은 메모리가 필요하다
2. 세션 저장소에 저장될 때마다 모든 서버에 입력해야 하므로 트래픽 증가로 인해 서버수가 증가할떄 성능 저하가 발생한다.
3. 여러 대의 서버로 하나의 서비스를 위해 사용함으로써 데이터 불일치가 잠재적으로 발생할 수 있다. (클러스터링 되기 전에 서비스를 요청 시, 잘못된 데이터가 불러올 수 있다.)

![Untitled](%E1%84%89%E1%85%A6%E1%84%89%E1%85%A7%E1%86%AB%2025b78b03a7494e97b95d61ccfd8fef0e/Untitled%201.png)

<br><br>

### 2.3.3 세션 스토리지 분리 (Inmemory DB)

> 기존 서버가 갖고 있는 세션 저장소를 이용하는 것이 아니라, 별도의 세션 저장소(Redis, Memcache)를 사용하여 세션 스토리지를 분리하는 것이다.
>
> Inmemory DB 란 데이터 스토리지의 메인 메모리에 설치되어 운영되는 방식의 데이터 베이스 시스템이다.  
> 메모리 접근이 디스크 접근보다 빠르며 데이터를 조회할 떄 검색 시간이 줄어든다.

- 세션 스토리지가 분리되면 서버가 아무리 늘어난다고 할 지라도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있다.
- 또한, 세션 저장소의 데이터 불일치가 발생하지 않는다.
- 그러나, 하나의 세션 저장소를 운영하는 것은 해당 세션 저장소가 장애가 발생하면 모든 세션이 이용 불가능하기 떄문에 복제를 구성하는 것이 좋다.

![Untitled](%E1%84%89%E1%85%A6%E1%84%89%E1%85%A7%E1%86%AB%2025b78b03a7494e97b95d61ccfd8fef0e/Untitled%202.png)
# 세션

> 일정 시간동안 같은 사용자(브라우저)로부터 들어오는일련의 요구를 하나의 상태로 보고,  
> 그 상태를 일정하게 유지시키는 기술이다.
> 
> 여기서 일정 시간은 방문자가 웹 브라우저를 통해  
> 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.
> 

- 즉, **방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션**이라고 한다.


<br><br>


## 2.1 특징

- 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.

- 웹 서버의 저장되는 쿠키(=세션 쿠키)

- 브라우저를 닫거나, 서버에서 세션을 삭제했을때만 삭제가 되므로,쿠키보다 비교적 보안이 좋다.

- 저장 데이터에 제한이 없다.(서버 용량에 따라 다르다.)

- 각 클라이언트 고유 Session ID를 부여한다. 
    Session ID로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스 제공

<br><br>

## 2.2 흐름

1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)

2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여,클라이언트가 해당 session-id를 보냈는지 확인한다.

3. session-id가 존재하지 않는다면,서버는 session-id를 생성해 클라이언트에게 돌려준다.

4. 서버에서 클라이언트로 돌려준 session-id를 쿠키(JSESSIONID)를 사용해 서버에 저장한다.

5. 클라이언트는 재접속 시,이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달

<br><br>

## 2.3 분산 환경에서의 Session 관리

### 2.3.1 Sticky Session

> 고정된 세션 의미한다. Load Balance가 기본적으로 라운드 로빈 방식으로 트래픽을 분산하며, Sticky Session 의 핵심은 로드밸런스가 동일한 인스턴스로 사용자 요청을 일관되게 라우팅 하도록하느냐 이다.

즉, 특정 사용자가 접속을 시도했을 떄 처음 접속된 서버로 계속해서 접속되도록 트래픽을 처리하는 방식이다.
> 

- 정합성 이슈에서 자유로워질 수 있다.
- 특정 서버에 트래픽이 집중될 위험이 있기 떄문에 하나의 서버에 트래픽이 집중되더라도 다른서버를 사용할 수가 없다.
- 또한, 하나의 서버에 장애가 발생한다면 해당 서버를 사용하는 사용자들은 세션정보를 잃게 되어 가용성이 떨어진다. (즉, failover가 안된다)

<img src="https://github.com/ryunian/Study/blob/master/image/StickySession.png?raw=true" width="700px" height="500px">

<br><br>

### 2.3.2 Session Clustering

> Session Clustering 은 정합성 이슈를 해결하면서 가용성과 트래픽 분산까지 확보 할 수 있는 세션관리 방식이다.
> 
- Clustering 이란 여러 대의 컴퓨터들이 하나의 시스템처럼 동작하도록 만드는 것이며,
- Session Clustering은 WAS가 2대 이상 설치 형태일 떄 동일한 세션으로 관리하는 것을 의미한다.
- 즉, 특정 WAS에 세션 객체가 생성되면 다른 WAS에 세션 객체가 복제된다.

단점)

1. 모든 서버가 동일한 세션 객체를 가져야하기 때문에 많은 메모리가 필요하다
2. 세션 저장소에 저장될 때마다 모든 서버에 입력해야 하므로 트래픽 증가로 인해 서버수가 증가할떄 성능 저하가 발생한다.
3. 여러 대의 서버로 하나의 서비스를 위해 사용함으로써 데이터 불일치가 잠재적으로 발생할 수 있다. (클러스터링 되기 전에 서비스를 요청 시, 잘못된 데이터가 불러올 수 있다.)

<img src="https://github.com/ryunian/Study/blob/master/image/SessionClustering.png?raw=true" width="700px" height="500px">

<br><br>

### 2.3.3 세션 스토리지 분리 (Inmemory DB)

> 기존 서버가 갖고 있는 세션 저장소를 이용하는 것이 아니라, 별도의 세션 저장소(Redis, Memcache)를 사용하여 세션 스토리지를 분리하는 것이다.
>
> Inmemory DB 란 데이터 스토리지의 메인 메모리에 설치되어 운영되는 방식의 데이터 베이스 시스템이다.  
> 메모리 접근이 디스크 접근보다 빠르며 데이터를 조회할 떄 검색 시간이 줄어든다.

- 세션 스토리지가 분리되면 서버가 아무리 늘어난다고 할 지라도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있다.
- 또한, 세션 저장소의 데이터 불일치가 발생하지 않는다.
- 그러나, 하나의 세션 저장소를 운영하는 것은 해당 세션 저장소가 장애가 발생하면 모든 세션이 이용 불가능하기 떄문에 복제를 구성하는 것이 좋다.

<img src="https://github.com/ryunian/Study/blob/master/image/InMemoryDB.png?raw=true" width="700px" height="500px">